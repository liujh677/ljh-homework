
1.**1000011，1111001，1111100**

 

2.**1010011**

3.**x = 11010011**

4.**1111111，1111001，1111000**


5.**1.001**


6.**x = 10111.0**


7.**x = 0.01110011001100...**

**2、4出现溢出错误，7出现精度误差**





1. **Method of complements**

**在数学和计算中,补码的方法是一种只用正数相加来减去一个数字和另一个数字的技术。这种方法常用于机械计算器,现代计算机仍然使用。**


2. **Byte**

**字节（港澳台作位元组，英语：Byte），通常用作计算机信息计量单位，不分数据类型。 一个字节代表八个比特（港澳台作位元，英语：Bit）。从历史的观点上，“字节”表示用于编码单个字符所需要的比特数量。历史上字节长度曾基于硬件为1-48比特不等，最初通常使用6比特或9比特为一字节。今日事实标准以8比特作为一字节，因8为二进制整数。**

3. **Integer (computer science)**

**integer是一种数据类型，表示保存的数据类型为整数，integer用于保存整数。如果知道变量总是存放整数，则应该将其申明为Interger类型或Long 类型。整数的运算速度快，而且占用的内存少。**

4. **Floating point**

**浮点型其实就表示实数类型，可用于表示有小数点的数。**

**浮点运算就是x小数的加减乘除运算**

**在计算机的硬件中是没有小数点这个东西的。cpu能处理的东西都是整的。所以，小数就要用类似科学计数法的方式来表示。如1.234在计算机里面，可以理解成用1234和-3两个整数来表示1234*10的-3次方，这类数就叫浮点数。由于这种表示方法的局限性和复杂性。计算机中的实数是有精度限制的。比如只能精确到小数点后20位，而且，cpu在处理这类数的运算时需要比整数运算复杂得多的电路设计，且速度比整数慢很多。**


**证明：**

**Negative(x) = 2k - x=(2k-1-x) + 1**

**(2k-1-x) 为 x 的反码**

**得证**

**八进制描述变量x：x = 0761**

**C程序：int8_t x = -0x1f; int y = x; 请用16进制描述变量 x 和 y，并说明 int y = x 的计算过程。**

**x = 0xe1**

**y = 0xffffffe1**

**计算过程：**
**x = -0x1f = 1 110 0001**

**y = x = 1 1110 0001 （重复符号位）= 1 111 1111 1111 1111 1111 1111 1110 0001（右移并添1）**

**数学证明：。。。**



**NaN：**

**IEEE 754 specifies a special value called "Not a Number" (NaN) to be returned as the result of certain "invalid" operations, such as 0/0, ∞×0, or sqrt(−1).**